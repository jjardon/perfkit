----------------------------------------------------------------------------
                              Hacking Perfkit
----------------------------------------------------------------------------

Source Overview
===============

  /
  |
  +- build/
  |
  |  Various build system scripts and utilities required.  This includes such
  |  things as m4 macros and autotools plugins.
  |
  +- perfkit-daemon/
  |
  |  The daemon which runs on the target machine to manage perfkit plugins
  |  and child processes.  The daemon orchestrates *how* things happen on
  |  the target (as opposted to *what*).  This could also be called the
  |  Agent.
  |
  +- perfkit-daemon/encoders/
  |
  |  Encoders are responsible for convering recoreded Samples and Manifests
  |  (which describe a series of samples) into buffers which can be decoded
  |  on the other end.  They can provide various features such as compression
  |  and encryption.
  |
  +- perfkit-daemon/listeners/
  |
  |  Listeners provide connectivity into the daemon over a form of RPC.  This
  |  includes DBus, TCP, or another transport.
  |
  +- perfkit-daemon/sources/
  |
  |  Sources are the plugins into the daemon which extract information from
  |  a single or group of processes.  They, for example, could extract memory
  |  or network throughput and create samples to be passed on to the client.
  |
  +- perfkit/
  |
  |  This directory contains the shared-library that can be used to talk to
  |  a perfkit-daemon.  It abstracts the communication protocol for the
  |  host process so they need not be concerned whether it is DBUS, HTTP,
  |  or some other protocol.
  |
  |  The shared library provides proxy objects that represent the objects
  |  available on the connected daemon.
  |
  +- tools/
  |
  |  The tools directory contains various tools to help manage or interact
  |  with a target running perfkit.  The perfkit-shell provides an
  |  interactive, readline-based, shell for controlling a daemon.  A
  |  support script is also provided that will eventually dump a significant
  |  amount of data on the target machine for someone to debug any problems
  |  that are occuring.
  |
  +- data/
  |
  |  The data directory contains data files that may be installed onto the
  |  target host.  This includes files such as DBUS introspection xml.
  |
  +- cut-n-paste/
  |
  |  The cut-n-paste directory contains files that we consume in perfkit that
  |  can be copied verbatim from other source trees.  It is desired to keep
  |  these files unchanged so the process of updating them is as simple as
  |  dropping in a new file.
  |
  +- tests/
  |
  |  This directory contains automated tests that are written using the GLib
  |  testing framework.  They are meant to be run before checking in new code
  |  within critical paths.
  |

perfkit-daemon
==============

  The perfkit daemon is a process which runs on a target system that manages
  the profiling or systems monitoring.  It can spawn processes to profile
  as well as profile existing ones.  It provides an RPC mechanism to control
  the daemon remotely over such transports as DBUS.

  Data sources, which provide profiling instrumentation, are provided through
  perfkit-daemon plugins.  Good examples of a data sources would be memory
  profilers, network bandwidth monitors, or cpu recorders.

  Perfkit daemon provides an abstraction called "Channels".  A channel is a
  collection of data sources which are aggregated together.  They can be
  accessed in aggregate from a client connecting to the daemons RPC
  mechanism.

  Plugins for perfkit-daemon are provided using the Ethos plugin library.
  More information on Ethos can be found at:

    http://git.dronelabs.com/ethos

  Data sources, when recording, create "Samples".  Samples are nuggets of
  information about the inferior process (the target).  They can contain
  arbitrary information and are backhauled to interested clients through
  their aggregation channel.


  A rough visual pictogram would look like:


    {client} --- {DBUS,...} --- {Daemon} --- {Channel} --- {Source,...}

  In this case, the client is connecting to the perfkit-daemon over DBUS.
  Inside the daemon exists a Channel which has various Sources attached
  to it.  When those data sources yield new instrumentation samples, they
  are delivered to the Channel who then aggregates them.  The client can
  receive the channels and is free to do with them what it desires.

  For example, it might be interesting to simply log the samples to a file
  for later analysis.  A simple file format could be constructed to record
  the samples as they come off the logical "wire" and stored to disk.

libperfkit-1.0
==============

  NOTE:
         THIS IS PENDING A REWRITE TO MATCH THE NEW DAEMON DESIGN
         --------------------------------------------------------

  Libperfkit is a shared library that reduces the complexity in talking to
  a remote perfkit-daemon.  It provides a transport abstraction so the
  physical transport used is not the problem of the client.  The standard
  connection used is DBUS for local profiling.  You can use the library
  to create a new connection as such:

    PkConnection *conn = pk_connection_new_for_uri ("dbus://");

  Currently, only DBUS is supported.

  Proxy objects are provided for access services of the remote
  perfkit-daemon.  The PkChannels class provides access to the Channels
  service (which is available over DBUS).  Using your newly created
  connection, you can get access to this service.

    PkChannels *channels = pk_connection_get_channels (conn);

  If you intend on storing a reference to this GObject, you should reference
  it with g_object_ref();

  Using this channels proxy, you can create new channels and manipulate
  them as if they were in your local process.  For example, to create a
  new Channel:

    PkChannel *channel = pk_channels_add (channels);

  When you are done with the channel, you should unreference it:

    g_object_unref (channel);

  The basic format of the shared library follows the semantics of the
  perfkit-daemon.

    / PkConnection
    |
    |   Abstracts the transport protocol used to talk to the daemon.
    |   Currently, DBUS is supported.
    |
    +- PkChannels
    |
    |  Gives you access to the Channels service within the perfkit-daemon.
    |  This includes creating, removing, and finding channels.
    |
    +--- PkChannel
       |
       |  Proxy for an individual channel found on the remote perfkit-daemon.
       |  Provides access to manipulate the channel.  Also can start, stop,
       |  pause, unpause, and receive samplse from the channel.
       |
    +- PkSources
    |
    |  Gives you access to the Sources service within the perfkit-daemon.
    |  This includes creating, removing, and finding sources.
    |
    +--- PkSource
       |
       |  Proxy for an individual source found on the remote perfkit-daemon.
       |  Provides access to manipulate the source.
       |

  Profiling sample delivery is a critical path in the lifecycle of the
  perfkit-daemon and client.  Perfkit, by default, uses the DBUS for
  communicating with clients.  The particular DBUS connection used is managed
  by the DBUS daemon and therefore has a decent amount of overhead. Therefore,
  a private connection between the client and the daemon is created and the
  DBUS serialization protocol is used in a peer-to-peer manner.

perfkit-shell
=============

  Perfkit-shell is an interactive, readline-based shell.  It is pretty strait
  forward and uses EggLine to provide the shell interaction.  EmtFmt is used
  to format console based text where appropriate so that it is easy to read.

  The shell uses libperfkit to communicate to the perfkit-daemon.  The goal
  is for the shell to be able to talk to remote servers as well as the local
  daemon.

perfkit-support
===============

  Perfkit-support provides a support tool for administrators to dump
  information about a malfunctioning perfkit-daemon for post analysis.
  Ideally, it will include any necessary core-dumps, information about
  running processes, their children, loaded libraries, logs, and other
  troubleshooting information.

----------------------------------------------------------------------------
                                 Roadmap
----------------------------------------------------------------------------

Milestone I.
============

 * Spawning a new process with arguments.
 * Ability for data sources to alter environment variables prior to process
   spawning.
 * Data sources for:
   - System Memory
   - System CPU
   - GLib Memory Allocations
 * Ability to set sampling frequencies.
 * Console shell to manipulate commands and monitor on the fly.
 * Start on user interface using Gtk with plugins using Ethos.

Milestone II.
=============

 * Export input/output stream for spawned processes over DBUS.
 * Data sources for:
   - Power consumption
   - Network traffic
   - Gtk/Gdk events
 * API Review.
 * Security Review.
 * Python bindings.

Milestone III.
==============

 * Start stablizing API.
 * Start implementing security.

